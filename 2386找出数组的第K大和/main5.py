"""
给你一个整数数组 nums 和一个 正 整数 k 。你可以选择数组的任一 子序列 并且对其全部元素求和。
数组的 第 k 大和 定义为：可以获得的第 k 个 最大 子序列和（子序列和允许出现重复）
返回数组的 第 k 大和 。
子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。
注意：空子序列的和视作 0 。

示例 1：
输入：nums = [2,4,-2], k = 5
输出：2
解释：所有可能获得的子序列和列出如下，按递减顺序排列：
- 6、4、4、2、2、0、0、-2
数组的第 5 大和是 2 。

示例 2：
输入：nums = [1,-2,3,4,-10,12], k = 16
输出：10
解释：数组的第 16 大和是 10 。
 

提示：
n == nums.length
1 <= n <= 105
-109 <= nums[i] <= 109
1 <= k <= min(2000, 2n)

认输了，用官方解法的思想去实现
最小堆来取最小和的子序列
还有二分？？？

"""
from typing import List
import heapq

class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        top_sum = sum(num for num in nums if num>0)
        nums = [abs(nums[i]) for i in range(len(nums))]
        nums = sorted(nums, key=abs)
        print(nums)

        # The first stores the sum of the subset
        # The second stores the last element's index
        pq = [(0, None)]
        if k == 1:
            sub = 0
        popcorn = heapq.heappop(pq)
        heapq.heappush(pq, (nums[0], 0))

        for count in range(1, k):
            popcorn = heapq.heappop(pq)
            print('pop', popcorn)
            if count == k-1:
                sub = popcorn[0]
            
            # 下标也是烦人的
            # 弹出的次数比压入的更多了的话，那就没有的压入了
            if popcorn[1]+1 >= len(nums):
                continue
            
            # Push的操作必须要到第二个才行，而pop是第一个就行
            print(f'push {(popcorn[0]+nums[popcorn[1]]+1, popcorn[1]+1)} {(popcorn[0]+nums[popcorn[1]+1]-nums[popcorn[1]], popcorn[1]+1)}')
            # 注意压入的内容，层数并不一定是count
            heapq.heappush(pq, (popcorn[0]+nums[popcorn[1]+1], popcorn[1]+1))
            heapq.heappush(pq, (popcorn[0]+nums[popcorn[1]+1]-nums[popcorn[1]], popcorn[1]+1))
        return top_sum-sub
 

'''
        for j in range(2, k + 1):
            t, i = heappop(pq)
            ret = t         # 这里隐含了一个条件，每次的最小值不是在上一个最小的一层就是在下一层，之后增加的影响不了之前的排序，每次确定的排序速度在有选择的情况下赶不上你更新的速度！
            # 优先队列 最小堆
            # 并且也是有方向的扩展，这样就相当于一个非常好的截止条件，避免了过多无用的存储，并且还有弹出使其变成线性增长不会太离谱
            # 只存储索引也进一步降低了空间量
            # 一道好的题目能学到很多呢，没有基础就不能快速打通联系
            # 给点改进的空间吧

            # 要是k很大的时候，提前跳过后续的层数，但还要接着弹到k
            if i == n - 1:
                continue
            heappush(pq, (t + nums[i + 1], i + 1))
            heappush(pq, (t - nums[i] + nums[i + 1], i + 1))
'''
if __name__ == '__main__':
    solution = Solution()
    nums, k = [153123449,-974739108,-408679566,-996444415,-978921261,805907128,-102259288,-397930077,51033052,-193994032,158654659,-486195972,-294264190,-65262667,375941242,-890038230,315970860,403847239,-32469129,-350561293,192113942,794248972,-632675681,434029943,746632801,500370163,164413366,346449701,473890512], 1906
    nums, k = [1000,1001,1002,1003,1004,1005,1006,1007,1008,1009], 10
    nums, k = [-91282107,-541711002,-276822556,90917395,834041510,-840892824,-508608840,-147048391,557843113,272412766,-918980912,820869808,385517519,-341785025,486628402,993154325,-629135417,677219246,62835597,64218970,928242835,896481126,-738154826,478700010,-893696727,-119562113,-43819130,-987768829,157402884,-386180872,237072809,-919540108,267447436,201913793,-281453262,168068441,690937145,894616338,428922554,355032016,-282793837,-445107592,-559015912,266029154,-245027665,324705364,-727272924,186301685,-905146561,-209906218,111448330,7925324,-103030197,62731785,652384508,242259114,56539784,69378804,190147339,-844137898,-595488526,-731717935,-480766744,767916483,119646172,16969979,906477612,387179801,-845067849,-703297363,816507867,436741820,285885943,-305638994,374442522,-657030826,-770219295,-543436120,612879155,646087640,-403176698,393578994,-155171985,-408422544,-487489088], 1477
    nums, k = [1,-2,3,4,-10,12], 16
    nums, k = [2, 4, -2], 5
    answer = solution.kSum(nums, k)
    print(answer)
